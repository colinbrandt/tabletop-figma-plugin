(()=>{"use strict";({168:function(){var e=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(a,o){function s(e){try{c(i.next(e))}catch(e){o(e)}}function r(e){try{c(i.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,r)}c((i=i.apply(e,t||[])).next())}))};figma.showUI(__html__,{width:300,height:550});let t=!0;function n(e){const t=[...e];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t}function i(e){if("children"in e){const t=e.findOne((e=>"Front"===e.name)),n=e.findOne((e=>"Back"===e.name));t&&n?t.visible?(t.visible=!1,n.visible=!0):(t.visible=!0,n.visible=!1):figma.notify('Selected node must have both "Front" and "Back" layers.')}else figma.notify("Selected node does not contain any children.")}figma.on("selectionchange",(()=>e(void 0,void 0,void 0,(function*(){const n=figma.currentPage.selection.filter((e=>"INSTANCE"===e.type));if(figma.ui.postMessage({type:"update-selection-count",count:n.length}),t&&n.length>0){const e=n.filter((e=>"INSTANCE"===e.type));e.length>0&&function(e){const t=e.slice().sort(((e,t)=>{const n=e.parent;return null===n?0:n.children.indexOf(e)-n.children.indexOf(t)}));for(const e of t)e.parent&&e.parent.appendChild(e)}(e)}if(1===n.length){figma.ui.postMessage({type:"loading-card"}),console.log('Sent "loading-card" message');const t=n[0],i=yield function(t){return e(this,void 0,void 0,(function*(){try{const e=t.findOne((e=>"Preview"===e.name));if(e&&"RECTANGLE"===e.type)if(Array.isArray(e.fills)){const t=e.fills;if(t.length>0){const e=t[0];if("IMAGE"===e.type&&e.imageHash){const t=figma.getImageByHash(e.imageHash);if(t){const e=yield t.getBytesAsync();return`<img src="${"data:image/png;base64,"+figma.base64Encode(e)}" alt="Preview" style="max-width: 100%; max-height: 100%;" />`}console.error("Image not found for imageHash:",e.imageHash)}}}else console.error("Preview layer fills is not an array");const n=t.clone(),i=n.findOne((e=>"Front"===e.name)),a=n.findOne((e=>"Back"===e.name));i&&a&&(i.visible=!0,a.visible=!1);const o=yield n.exportAsync({format:"SVG_STRING"});return n.remove(),o}catch(e){return console.error("Error generating preview data:",e),figma.notify("Error generating preview data"),""}}))}(t);figma.ui.postMessage({type:"preview-card",data:i}),console.log('Sent "preview-card" message with data')}else figma.ui.postMessage({type:"preview-card",data:null}),console.log('Sent "preview-card" message with null data')})))),figma.ui.onmessage=a=>e(void 0,void 0,void 0,(function*(){var e;if("update-bring-to-top-toggle"===a.type&&(e=a.value,t=e),"randomize-order"===a.type){const e=figma.currentPage.selection;if(e.length>0){const t=e[0].parent;t?(n(e).forEach((e=>t.appendChild(e))),figma.notify("Objects shuffled")):figma.notify("Selected layers do not have a common parent.")}else figma.notify("Please select some layers.")}if("toggle-flip-card"===a.type){const e=figma.currentPage.selection;e.length>0?(e.forEach((e=>{i(e)})),figma.notify("Card flipped")):figma.notify('Please select a layer with "Front" and "Back" child layers.')}if("form-deck"===a.type){const e=figma.currentPage.selection.filter((e=>"INSTANCE"===e.type));if(e.length>0){const t=e[0].parent;if(t){const a=Math.min(...e.map((e=>e.x))),o=(e.reduce(((e,t)=>e+t.y),0),e.length,n(e));let s=Math.min(...o.map((e=>e.y)));o.forEach(((e,n)=>{"INSTANCE"===e.type&&(e.x=a,e.y=s-n,e.setPluginData("Flip card?","false"),i(e),t.appendChild(e))})),figma.notify("Objects stacked and shuffled")}else figma.notify("Selected objects do not have the same parent")}else figma.notify("Please select some objects")}if("expand-deck"===a.type){const e=figma.currentPage.selection.filter((e=>"INSTANCE"===e.type));if(e.length>0){let t=e[0].x,n=e[0].y;e.forEach((e=>{i(e),e.x=t,t+=e.width+16,e.y=n})),figma.notify("Objects expanded")}else figma.notify("Please select some objects")}}))}})[168]()})();